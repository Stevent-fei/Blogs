# golang面试常问问题
# 什么是进程，线程，协程

> 进程是正在运行的程序的实例，有独立的内存空间和系统资源；  
> 线程是进程中执行代码的单个执行单元,共享进程的内存空间和系统资源；  
> 协程是轻量级的线程，由应用程序自己管理，可以实现更高的并发性和更低的开销。

# golang中new和make的区别？

> make和new都是用来分配内存的
> make只能创建slice、map和channel这三种引用类型，而new可以创建任意类型的对象。  
> make创建的对象已经进行了初始化，而new创建的对象还需要手动初始化。

# golang中的数组和切片(slice)的区别，以及底层是由什么组成,

> 底层是数组
> 数组的长度是固定的，切片的长度是可变的。  
数组的长度是在定义时确定的，切片的长度可以在运行时动态扩展。  
数组是值类型，传递时会复制整个数组，切片是引用类型，传递时只会复制一个指针，多个切片可以共享底层数组。  
数组不能改变长度，只能通过重新定义新的数组来改变元素个数，切片可以使用append()函数来动态增加元素。  
数组和切片的遍历方式不同。数组使用for循环和下标方式遍历，切片使用for循环和range方式遍历。

# 切片扩容策略是什么

> 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。  
> 注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

# golang中的defer,什么场景中遇到过

> defer是一种后进先出的运行机制，用于在函数返回时执行一段代码（defer通常用于资源的释放、日志记录等场景）  
> 讲讲 Go 的 defer 底层数据结构和一些特性？  
> 每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

# 16. golang channel带缓冲区和不带缓冲区的区别

> 1. 带缓冲区: 带缓冲区的Channel与不带缓冲区的Channel的主要区别在于，带缓冲区的Channel在发送数据时不会阻塞协程，只有在缓冲区已满的情况下才会阻塞。
> 2. 不带缓冲区: 而不带缓冲区的Channel在发送数据时会直接阻塞协程，直到有另一个协程接收到数据为止。

# Chan

> 无缓冲 Chan 的发送和接收是否同步?

```shell
// 无缓冲的channel由于没有缓冲发送和接收需要同步
ch := make(chan int)   
//有缓冲channel不要求发送和接收操作同步
ch := make(chan int, 2)  
```

> channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据；channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

# channel 为什么它可以做到线程安全？

> Channel 可以理解是一个先进先出的队列，通过管道进行通信,发送一个数据到Channel和从Channel接收一个数据都是原子性的。  
> 不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的。

# select可以用于什么，常用于gorotine的完美退出

> select用于监听channel，可以同时响应多个通道，类似于switch语句，有一系列的case分支和默认分支


# select 的特性

1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）多个 case 语句的执行顺序是随机的。

5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。





# 1. 什么是goroutine和channel？

> goroutine是Go语言中的一种轻量级线程，可以在同一个进程内并发运行，由Go语言原生支持。channel是在不同的goroutine之间进行通信的一种特殊类型。

# 2. Go语言的优点是什么？

> Go语言具有高效的并发编程能力、简单清晰的语法、自动内存管理、跨平台支持、快速编译和执行等优点。

# 3. 如何实现并发编程？

> 在Go语言中，可以使用goroutine和channel实现并发编程。goroutine是轻量级线程，可以在同一个进程内并发运行。channel是用于在不同的goroutine之间进行通信的一种特殊类型。

# 4. 如何进行错误处理？

> Go语言中可以使用error类型和panic/recover机制进行错误处理。error类型用于表示函数执行是否成功，而panic/recover机制用于处理异常情况。

# 5. Go语言中的内存管理是如何实现的？

> Go语言中的内存管理是通过垃圾回收机制来实现的。垃圾回收器会自动管理不再被引用的对象，并回收其所占用的内存空间。

# 6. 如何进行性能优化？

> 在Go语言中，可以通过使用原生支持的并发编程、避免过度分配和复制、使用指针等方法进行性能优化。

# 7. 什么是闭包？

> 闭包是一种函数，可以访问其自身作用域之外的变量。在Go语言中，闭包通常由函数和外部变量组成，并且可以作为参数传递或返回值返回。

# 8. Go语言中的接口是什么？

> 接口是一种抽象类型，定义了一组方法。在Go语言中，接口通常由方法集合组成，并用于实现多态性。

# 9. 如何进行并发控制？

> 在Go语言中，可以使用锁、互斥体和条件变量等机制进行并发控制。锁和互斥体用于保护共享资源，条件变量用于等待和通知事件。

# 10. 什么是defer？

> defer是Go语言中的一种语言结构，用于在函数返回时执行一段代码。在Go语言中，defer通常用于资源的释放、日志记录等场景。

# 11. 如何进行性能分析？

> Go语言中可以使用pprof工具进行性能分析。  
> pprof工具可以生成CPU和内存分析报告，帮助开发人员优化程序性能。

# 12.协程，线程，进程的区别

> 进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。  
> 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

> 线程 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)  
> ,但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

> 协程 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。  
> 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

# GC（三色标记法）

> 初始状态下所有对象都是白色的。 
> 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。 
> 循环步骤3，直到灰色对象全部变黑色。  
> 通过写屏障(write-barrier)检测对象有变化，重复以上操作 收集所有白色对象（垃圾）。



# 14. Channel是同步的还是异步的？

> Channel是异步进行的, channel存在3种状态：
> nil，未初始化的状态，只进行了声明，或者手动赋值为nil  
> active，正常的channel，可读或者可写  
> closed，已关闭，千万不要误认为关闭channel后，channel的值是nil

```shell
  操作     一个零值nil通道   一个非零值但已关闭的通道         一个非零值且尚未关闭的通道 
  关闭      产生恐慌          产生恐慌                     成功关闭 
  发送数据   永久阻塞          产生恐慌                     阻塞或者成功发送 
  接收数据   永久阻塞          永不阻塞                     阻塞或者成功接收
```





# 17. golang中的并发安问题；锁，什么是死锁，什么场景中会有

> 读数据的时候会有不会有并发安全问题，写数据的时候会有并发安全问题
>
> 锁，分为`互斥锁`和`读写锁`  
> 互斥锁：完全是互斥的，一个goroutine执行完成后，另外一个执行goroutine才能获取锁，多个goroutine同时等待一个锁时，唤醒的策略是随机的  
> 读写锁：读写锁分为读锁和写锁，如果goroutine获取到的是读锁，那么会继续获取锁，如果获取到的是写锁，就会等待；当一个goroutine获取写锁后，其他的goroutine无论是获取读锁还是写锁，都会等待  
> 死锁：在并发编程中，当两个或多个进程（线程）相互等待对方的资源释放时，就会产生死锁（Deadlock），简单来说，就是每个进程都占用了一部分资源，
> 同时需要等待对方释放资源，以完成自己的任务，但是对方也一样，这时候就会造成死循环式的等待，进而导致整个系统崩溃。


# 20. int函数的作用以及特征

> init 函数用于包(package)的初始化，该函数是go语言的一个重要特征  
> 有下面的特征:

    1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 

    2 每个包可以拥有多个init函数

    3 包的每个源文件也可以拥有多个init函数

    4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)

    5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

    6 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用

# map

## 什么是map
> 在Golang中，map是一种数据结构，它允许将键映射到值。Map是一个无序的键/值对的集合，其中每个键必须是唯一的。  
> Map的键可以是任何可比较类型，例如字符串，数字或结构体，而值可以是任何类型。  
> 可以使用make函数创建新的map，然后使用键进行索引、添加、修改、删除和遍历map的元素。

> map提供了键值对的无序集合，所有的键都是不重复的。  
> map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。

# golang垃圾回收机制

> Go语言采用了现代化GC算法，实现了自动内存管理，也就是Go语言拥有自己的垃圾回收机制。Go语言的垃圾回收机制主要有三个组成部分：  
标记：标记所有活跃对象和未被使用的对象  
清除：清除未被使用的对象，这些对象的内存会被回收  
整理：在清除操作之后，重新整理内存，使内存空间连续，减少内存碎片

> 垃圾回收在Go语言中是自动进行的，没有显示调用的必要。当程序运行时，垃圾回收器会自动监测内存的使用情况，在需要回收内存的时候，自动执行垃圾回收操作。  
> 在垃圾回收的过程中，Go语言会暂停程序执行（STW），并且会耗费一定的CPU资源。因此，在开发过程中，需要注意内存的使用情况，尽量减少垃圾回收的频率，以提高程序的性能。


