# golang面试常问问题

# 1. 什么是goroutine和channel？

> goroutine是Go语言中的一种轻量级线程，可以在同一个进程内并发运行，由Go语言原生支持。channel是在不同的goroutine之间进行通信的一种特殊类型。

# 2. Go语言的优点是什么？

> Go语言具有高效的并发编程能力、简单清晰的语法、自动内存管理、跨平台支持、快速编译和执行等优点。

# 3. 如何实现并发编程？

> 在Go语言中，可以使用goroutine和channel实现并发编程。goroutine是轻量级线程，可以在同一个进程内并发运行。channel是用于在不同的goroutine之间进行通信的一种特殊类型。

# 4. 如何进行错误处理？

> Go语言中可以使用error类型和panic/recover机制进行错误处理。error类型用于表示函数执行是否成功，而panic/recover机制用于处理异常情况。

# 5. Go语言中的内存管理是如何实现的？

> Go语言中的内存管理是通过垃圾回收机制来实现的。垃圾回收器会自动管理不再被引用的对象，并回收其所占用的内存空间。

# 6. 如何进行性能优化？

> 在Go语言中，可以通过使用原生支持的并发编程、避免过度分配和复制、使用指针等方法进行性能优化。

# 7. 什么是闭包？

> 闭包是一种函数，可以访问其自身作用域之外的变量。在Go语言中，闭包通常由函数和外部变量组成，并且可以作为参数传递或返回值返回。

# 8. Go语言中的接口是什么？

> 接口是一种抽象类型，定义了一组方法。在Go语言中，接口通常由方法集合组成，并用于实现多态性。

# 9. 如何进行并发控制？

> 在Go语言中，可以使用锁、互斥体和条件变量等机制进行并发控制。锁和互斥体用于保护共享资源，条件变量用于等待和通知事件。

# 10. 什么是defer？

> defer是Go语言中的一种语言结构，用于在函数返回时执行一段代码。在Go语言中，defer通常用于资源的释放、日志记录等场景。

# 11. 如何进行性能分析？

> Go语言中可以使用pprof工具进行性能分析。  
> pprof工具可以生成CPU和内存分析报告，帮助开发人员优化程序性能。

# 12.协程，线程，进程的区别

> 进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。  
> 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

> 线程 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)  
> ,但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

> 协程 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。  
> 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

# GC

> 1.2 三色标记法 初始状态下所有对象都是白色的。 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。 循环步骤3，直到灰色对象全部变黑色。  
> 通过写屏障(write-barrier)检测对象有变化，重复以上操作 收集所有白色对象（垃圾）。

# Chan

> 无缓冲 Chan 的发送和接收是否同步?

```shell
// 无缓冲的channel由于没有缓冲发送和接收需要同步
ch := make(chan int)   
//有缓冲channel不要求发送和接收操作同步
ch := make(chan int, 2)  
```

> channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据；channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

# golang中new和make的区别？

> 用new还是make？到底该如何选择？  
> make和new都是用来分配内存的
> make 仅用来分配及初始化类型为 slice、map、chan 的数据。  
> new 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 *Type。

# 13. channel 为什么它可以做到线程安全？

> Channel 可以理解是一个先进先出的队列，通过管道进行通信,发送一个数据到Channel和从Channel接收一个数据都是原子性的。  
> 不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的。

# 14. Channel是同步的还是异步的？

> Channel是异步进行的, channel存在3种状态：
> nil，未初始化的状态，只进行了声明，或者手动赋值为nil  
> active，正常的channel，可读或者可写  
> closed，已关闭，千万不要误认为关闭channel后，channel的值是nil

```shell
  操作     一个零值nil通道   一个非零值但已关闭的通道         一个非零值且尚未关闭的通道 
  关闭      产生恐慌          产生恐慌                     成功关闭 
  发送数据   永久阻塞          产生恐慌                     阻塞或者成功发送 
  接收数据   永久阻塞          永不阻塞                     阻塞或者成功接收
```

# 15. golang中的数组和切片(slice)的区别，以及底层是由什么组成,切片扩容策略是什么

> 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。  
> 注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

# 16. golang channel带缓冲区和不带缓冲区的区别

> 1. 带缓冲区: 带缓冲区的Channel与不带缓冲区的Channel的主要区别在于，带缓冲区的Channel在发送数据时不会阻塞协程，只有在缓冲区已满的情况下才会阻塞。
> 2. 不带缓冲区: 而不带缓冲区的Channel在发送数据时会直接阻塞协程，直到有另一个协程接收到数据为止。

# 17. golang中的并发安问题；锁，什么是死锁，什么场景中会有

> 读数据的时候会有不会有并发安全问题，写数据的时候会有并发安全问题
>
> 锁，分为`互斥锁`和`读写锁`  
> 互斥锁：完全是互斥的，一个goroutine执行完成后，另外一个执行goroutine才能获取锁，多个goroutine同时等待一个锁时，唤醒的策略是随机的  
> 读写锁：读写锁分为读锁和写锁，如果goroutine获取到的是读锁，那么会继续获取锁，如果获取到的是写锁，就会等待；当一个goroutine获取写锁后，其他的goroutine无论是获取读锁还是写锁，都会等待  
> 死锁：在并发编程中，当两个或多个进程（线程）相互等待对方的资源释放时，就会产生死锁（Deadlock），简单来说，就是每个进程都占用了一部分资源，
> 同时需要等待对方释放资源，以完成自己的任务，但是对方也一样，这时候就会造成死循环式的等待，进而导致整个系统崩溃。

# 18. golang中的defer,什么场景中遇到过

> defer是一种后进先出（一般会在对文件操作，然后关闭文件使用）

# 19. golang中的select可以用于什么，常用语gorotine的完美退出

> select用于监听channel，可以同时响应多个通道，类似于switch语句，有一系列的case分支和默认分支

# 20. int函数的作用以及特征

> init 函数用于包(package)的初始化，该函数是go语言的一个重要特征  
> 有下面的特征:

    1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 

    2 每个包可以拥有多个init函数

    3 包的每个源文件也可以拥有多个init函数

    4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)

    5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

    6 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用

